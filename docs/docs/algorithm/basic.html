<!DOCTYPE html>
<html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="flattr:id" content="e7nqg5"> <title>基础算法杂谈 | Mooyyu Crab.’s Blog</title> <meta name="generator" content="Jekyll v3.9.0"> <meta property="og:title" content="基础算法杂谈"> <meta name="author" content="mooyyu"> <meta property="og:locale" content="en_US"> <meta name="description" content="一些基础算法的大杂烩"> <meta property="og:description" content="一些基础算法的大杂烩"> <link rel="canonical" href="https://mooyyu.github.io/docs/algorithm/basic.html"> <meta property="og:url" content="https://mooyyu.github.io/docs/algorithm/basic.html"> <meta property="og:site_name" content="Mooyyu Crab.’s Blog"> <meta property="og:type" content="article"> <meta property="article:published_time" content="2020-04-06T00:00:00+00:00"> <meta name="google-site-verification" content="0LZg36yiItnOtvXj-x8GPjsLmWZk9ujUR7nl6SRb28g"> <meta name="baidu-site-verification" content="code-0BzdQrWuUd"> <script type="application/ld+json">
{"headline":"基础算法杂谈","dateModified":"2020-04-06T00:00:00+00:00","datePublished":"2020-04-06T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mooyyu.github.io/docs/algorithm/basic.html"},"author":{"@type":"Person","name":"mooyyu"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://mooyyu.github.io/assets/images/logo/mooyyu/m.png"},"name":"mooyyu"},"description":"一些基础算法的大杂烩","url":"https://mooyyu.github.io/docs/algorithm/basic.html","@type":"BlogPosting","@context":"https://schema.org"}</script> <link rel="icon" href="/assets/favicon.ico"> <link rel="stylesheet" href="/assets/stylesheets/main.css?v=20210128-1"> <!--[if lt IE 9]><script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script> <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script><![endif]--> <script src="/assets/javascript/head.min.js"></script> <script type="text/javascript">

      /**
       * As Github pages do not support https for custom domains
       * this is the current best workaround for #18.
       */
      var domains  = [ 'mooyyu.github.io', 'localhost', '127.0.0.1' ];
      var pathname = location.pathname.replace(/^\/Mooyyu Crab.'s Github Page/, '')
      if (domains.indexOf(window.location.hostname) == -1)
        window.top.location.href = 'https://mooyyu.github.io' + pathname;

      /**
       * Another ugly workaround trying to improve UX reported by #35
       */
      if (location.protocol != 'https:' && window.location.hostname == 'mooyyu.github.io')
        location.href = 'https:' + window.location.href.substring(window.location.protocol.length);

      /**
       * Improves overall speed by loading javascript and css resources in parallel
       * with the main page.
       */
      head.load(
          "/assets/stylesheets/font-awesome.min.css",

          "/assets/javascript/jquery-2.2.1.min.js",
          "/assets/javascript/jquery-ui.min.js",
          "/assets/javascript/bootstrap.min.js",
          "/assets/javascript/tocify.min.js",
          "/assets/javascript/custom.js",

          "/assets/javascript/sheetrock.min.js",
          "/assets/javascript/cookieconsent.min.js",
          "/assets/javascript/pop.min.js"
      );

      head.ready(function() {
        window.cookieconsent_options = {
          "message":"This site use cookies to ensure you get the best experience on the website",
          "dismiss": "Got it!", "learnMore": "More info", "link":"", "theme": "dark-bottom"
        };
        $("body").on('click', '[data-stopPropagation]', function (e) {
          e.stopPropagation();
        });
      });
    </script> </head> <body role="document"> <nav class="navbar navbar-default navbar-fixed-top custom-no-margin"> <div class="container"> <div class="navbar-header"> <a href="/" class="navbar-brand" style="color: slategrey;"> Mooyyu Crab.'s Blog </a> <img id="daynite" src="/assets/images/btn-night.svg" alt="Dark Mode" width="32" height="32"> <button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#navbar-main"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> </div> <div class="navbar-collapse collapse" id="navbar-main"> <ul class="nav navbar-nav"> <li><a href="/whoami/">WHO AM I? </a></li> <li class="dropdown siteindex"> <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="navbar-documentation">Site Index <span class="caret"></span></a> <ul class="dropdown-menu"> <li class="dropdown dropdown-submenu algorithm"> <a href="#" class="dropdown-toggle" data-toggle="dropdown" data-stoppropagation="true" id="navbar-sub-algorithm">Algorithm</a> <ul class="dropdown-menu"> <li><a href="/meta/algorithm/"> All documents </a></li> <li class="divider"> <li><a href="/docs/algorithm/Math-1.html">算法竞赛简单数论知识(一)</a></li> <li><a href="/docs/algorithm/DP-knapsack.html">动态规划: 背包问题 (一)</a></li> <li><a href="/docs/algorithm/Graph-shortest_path.html">图论浅谈之最短路</a></li> <li><a href="/docs/algorithm/DP-linear.html">动态规划入门之线性极值模型</a></li> <li><a href="/docs/algorithm/DS-1.html">算法竞赛简单数据结构(一)</a></li> <li><a href="/docs/algorithm/Graph-segment_tree_scan.html">线段树之扫描线浅谈</a></li> <li><a href="/docs/algorithm/basic.html">基础算法杂谈</a></li> </ul> </li> <li class="dropdown dropdown-submenu oicode"> <a href="#" class="dropdown-toggle" data-toggle="dropdown" data-stoppropagation="true" id="navbar-sub-oicode">OI-code</a> <ul class="dropdown-menu"> <li><a href="/meta/oicode/"> All documents </a></li> <li class="divider"> <li><a href="/docs/oicode/B1.html"><strong>B1</strong>: 前缀和与差分</a></li> <li><a href="/docs/oicode/B2.html"><strong>B2</strong>: 快速组合</a></li> <li><a href="/docs/oicode/B3.html"><strong>B3</strong>: 二分查找</a></li> <li><a href="/docs/oicode/B4-add.html"><strong>B4</strong>: 高精度加法</a></li> <li><a href="/docs/oicode/B4-div.html"><strong>B4</strong>: 高精度除法</a></li> <li><a href="/docs/oicode/B4-multi.html"><strong>B4</strong>: 高精度乘法</a></li> <li><a href="/docs/oicode/B4-sub.html"><strong>B4</strong>: 高精度减法</a></li> <li><a href="/docs/oicode/D1.html"><strong>D1</strong>: 单调栈</a></li> <li><a href="/docs/oicode/D2.html"><strong>D2</strong>: 单调队列</a></li> <li><a href="/docs/oicode/D3.html"><strong>D3</strong>: Spare Table</a></li> <li><a href="/docs/oicode/D4.html"><strong>D4</strong>: 字典树</a></li> <li><a href="/docs/oicode/D5.html"><strong>D5</strong>: 并查集</a></li> <li><a href="/docs/oicode/D6-rc.html"><strong>D6</strong>: 树状数组-限定区间计数</a></li> <li><a href="/docs/oicode/D6-surs.html"><strong>D6</strong>: 树状数组-单点更新区间求和</a></li> <li><a href="/docs/oicode/D7-basic.html"><strong>D7</strong>: 线段树-基础</a></li> <li><a href="/docs/oicode/G1.html"><strong>G1</strong>: 二分图-判定</a></li> <li><a href="/docs/oicode/G2.html"><strong>G2</strong>: 二分图-最大匹配</a></li> <li><a href="/docs/oicode/G3.html"><strong>G3</strong>: Astar k短路 on matrix</a></li> <li><a href="/docs/oicode/G4.html"><strong>G4</strong>: 拓扑排序</a></li> <li><a href="/docs/oicode/G5.html"><strong>G5</strong>: 连通无环无向图的重心</a></li> <li><a href="/docs/oicode/G6.html"><strong>G6</strong>: MST-Kruskal</a></li> <li><a href="/docs/oicode/G7.html"><strong>G7</strong>: MST-Prim</a></li> <li><a href="/docs/oicode/G8.html"><strong>G8</strong>: ShortestPath-BellmanFord</a></li> <li><a href="/docs/oicode/G9.html"><strong>G9</strong>: ShortestPath-Dijkstra</a></li> <li><a href="/docs/oicode/G9-hopt.html"><strong>G9</strong>: ShortestPath-Dijkstra Heap OPT</a></li> <li><a href="/docs/oicode/G10.html"><strong>G10</strong>: ShortestPath-SPFA</a></li> <li><a href="/docs/oicode/G11.html"><strong>G11</strong>: ShortestPath-Floyd</a></li> <li><a href="/docs/oicode/M1.html"><strong>M1</strong>: 快速幂与龟速乘</a></li> <li><a href="/docs/oicode/M2.html"><strong>M2</strong>: 欧几里得-最大公约数</a></li> <li><a href="/docs/oicode/M2-ft.html"><strong>M2</strong>: EX欧几里得-翡蜀定理</a></li> <li><a href="/docs/oicode/M2-lce.html"><strong>M2</strong>: EX欧几里得-线性同余方程</a></li> <li><a href="/docs/oicode/M2-mi.html"><strong>M2</strong>: EX欧几里得-乘法逆元</a></li> <li><a href="/docs/oicode/M3-flt.html"><strong>M3</strong>: 费马小定理-乘法逆元</a></li> <li><a href="/docs/oicode/M4.html"><strong>M4</strong>: 分解质因数</a></li> <li><a href="/docs/oicode/M4-euler.html"><strong>M4</strong>: 分解质因数-欧拉函数</a></li> <li><a href="/docs/oicode/M4-prc.html"><strong>M4</strong>: 分解质因数-多数乘积约数计数</a></li> <li><a href="/docs/oicode/M4-prs.html"><strong>M4</strong>: 分解质因数-多数乘积约数求和</a></li> <li><a href="/docs/oicode/M5.html"><strong>M5</strong>: 欧拉筛</a></li> <li><a href="/docs/oicode/M5-ps.html"><strong>M5</strong>: 欧拉筛-质数筛</a></li> <li><a href="/docs/oicode/M6.html"><strong>M6</strong>: 埃氏筛-质数筛</a></li> <li><a href="/docs/oicode/M7.html"><strong>M7</strong>: Stein算法-最大公约数</a></li> <li><a href="/docs/oicode/M8.html"><strong>M8</strong>: 矩阵乘法与快速幂</a></li> <li><a href="/docs/oicode/O1.html"><strong>O1</strong>: 快速排序</a></li> <li><a href="/docs/oicode/O2.html"><strong>O2</strong>: 并归排序</a></li> <li><a href="/docs/oicode/S1.html"><strong>S1</strong>: KMP</a></li> <li><a href="/docs/oicode/S2.html"><strong>S2</strong>: 字符串哈希</a></li> </ul> </li> </ul> </li> <li class="dropdown"> <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="navbar-algorithm">传统算法 <span class="caret"></span></a> <ul class="dropdown-menu"> <li><a href="/docs/algorithm/basic">基础算法杂谈</a></li> <li class="divider"> <li><a href="/docs/algorithm/DS-1">算法竞赛简单数据结构(一)</a></li> <li class="divider"> <li><a href="/docs/algorithm/DP-knapsack">动态规划:背包问题(一)</a></li> <li><a href="/docs/algorithm/DP-linear">动态规划入门之线性极值模型</a></li> <li class="divider"> <li><a href="/docs/algorithm/Graph-shortest_path">图论浅谈之最短路</a></li> <li><a href="/docs/algorithm/Graph-segment_tree_scan">线段树之扫描线浅谈</a></li> <li class="divider"> <li><a href="/docs/algorithm/Math-1">算法竞赛简单数论知识(一)</a></li> </ul> </li> <li class="dropdown"> <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="navbar-math">C++笔记 <span class="caret"></span></a> <ul class="dropdown-menu"> <li><a>🦉即将上线</a></li> </ul> </li> <li class="dropdown"> <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="navbar-math">数学笔记 <span class="caret"></span></a> <ul class="dropdown-menu"> <li><a>🦉即将上线</a></li> </ul> </li> <li class="dropdown"> <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="navbar-ai">AI笔记 <span class="caret"></span></a> <ul class="dropdown-menu"> <li><a>🦉即将上线</a></li> </ul> </li> </ul> <ul class="nav navbar-nav navbar-right visible-lg-block"> </ul> </div> </div> </nav> <div class="container" role="main"> <div class="row"> <div class="col-lg-3 col-md-4 visible-lg-block visible-md-block custom-no-padding"> <div class="custom-fixed-sidebar"> <div id="toc"></div> </div> </div> <div class="col-lg-9 col-md-8 custom-bg-white"> <div class="row"> <div class="col-md-12 custom-article"> <p class="text-right pull-right visible-lg-block hidden-print small custom-pt25"> <a href="//github.com/mooyyu" target="_blank" data-toggle="tooltip" data-placement="bottom" title="Visit mooyyu's profile on Github"><img class="avatar avatar-small" alt="mooyyu" width="30" height="30" data-proofer-ignore="true" src="https://avatars3.githubusercontent.com/mooyyu?v=3&s=30" srcset="https://avatars3.githubusercontent.com/mooyyu?v=3&s=30 1x, https://avatars3.githubusercontent.com/mooyyu?v=3&s=60 2x, https://avatars3.githubusercontent.com/mooyyu?v=3&s=90 3x, https://avatars3.githubusercontent.com/mooyyu?v=3&s=120 4x"></a> </p> <h1 class="custom-article-header">基础算法杂谈</h1> <p class="text-right pull-right small">06 April 2020</p> <p class="small"> 一些基础算法的大杂烩 </p> <h2 id="本文主要内容">本文主要内容</h2> <ul> <li>二分</li> <li>前缀和与差分</li> <li>常用排序及其基本应用</li> <li>位运算与二进制</li> <li>字符串哈希</li> </ul> <h2 id="二分">二分</h2> <h3 id="引入二分查找函数binary_search">引入：二分查找函数\(binary\_search\)</h3> <p>\(STL\)中的\(binary\_search(begin, end, value, comp = operator\!\!&lt;)\)函数的功能简单来说是<del>判断一个「单调」序列\([l, r)\)中是否存在「值」为\(value\)的元素</del>。但这样说是不严谨的，「单调」并不一定是指大小，相应地，「值」也并非一定是指数值，本质上来说，它们是针对于某种给定的性质而言的，而这性质由\(comp\)和\(value\)来共同描述。下面来详细分析一下这个函数。</p> <p><strong>函数功能:</strong>判断序列\([l, r)\)中是否存在满足「\(comp\)和\(value\)描述的性质」的元素，也即检查「基于比较方法\(comp\)，等于\(value\)」的元素是否在序列\([l, r)\)中。</p> <ul> <li>「基于比较方法\(comp\)，等于\(value\)」:若\(comp(element, value) = false\mbox{ &amp;&amp; }!comp(value, element) = true\)，则称\(element = value\)，即\(element\)满足「\(comp\)和\(value\)描述的性质」。</li> </ul> <p><strong>函数执行成功的条件:</strong>序列\([l, r)\)对于\(comp\)和\(value\)共同描述的性质单调，即满足下列条件：</p> <ul> <li>对于表达式\(comp(element, vale)\)，所有值为\(true\)的元素在值为\(false\)的元素的左边。</li> <li>对于表达式\(!comp(value, element)\)，所有值为\(true\)的元素在值为\(false\)的元素的左边。</li> <li>对于所有元素，若\(comp(element,value) = true\)，则\(!comp(value, element) = true\)。</li> </ul> <p>可以注意到，整个分析过程中是没有数值比较(大小比较和相等判断都没有)的，有的只是性质(表达式)的满足与否，这便是二分的本质。</p> <p>我们继续看看\(binary\_search\)是如何实现的：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ForwardIt</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Compare</span><span class="p">&gt;</span>
<span class="kt">bool</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">ForwardIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">ForwardIt</span> <span class="n">last</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">first</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">comp</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">comp</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">first</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div></div> <p>可以看到其内部是由\(lower\_bound\)实现的，而\(lower\_bound\)其实才是二分的真正实现，\(binary\_search\)仅仅是套个壳，是二分的一种特殊化的应用。下面我们进一步看看二分到底实现了什么。</p> <h3 id="探究二分的本质">探究：二分的本质</h3> <p>二分是最基础的算法思想，这里我们讨论更为普通的二分算法。</p> <p>对于一个给定的序列\([l, r)\)，一个给定的对于该序列中元素的条件\(check()\)，若满足下面的性质，则该序列对于该条件可以被二分求解，且二分一定能得到解。\(\exists mid\in [l, r)\)，将该序列划分为两个子序列\([l, mid),[mid, r)\)，满足下面两个条件之一</p> <ol> <li> \[[l, mid)\not = \emptyset, \forall e\in [l, mid), check(e) = true, \forall u\in [mid, r), check(u) = false\] </li> <li> \[[mid, r)\not = \emptyset, \forall e\in [mid, r), check(e) = true, \forall u\in [l, mid), check(u) = false\] </li> </ol> <p>那么二分得到的解的意义就是「该序列中满足给定条件的临界元素」。</p> <h4 id="二分的两种模型">二分的两种模型</h4> <p>在理论上二分的模型是统一的，但是在实际编码中，由于一个序列的两个子序列一定有位置之分（一般分为左右两个子序列），那么根据「左子序列中的元素满足条件」、「右子序列中的元素满足条件」可以分为左右两种模型。</p> <h5 id="右二分模型">右二分模型</h5> <p>此模型对应的是「左子序列中的元素满足条件」。因为二分的解的意义在这个模型中特化为「左子序列中最右边的元素」。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">type</span> <span class="p">&gt;</span>
<span class="n">type</span> <span class="nf">rfind</span><span class="p">(</span><span class="k">const</span> <span class="n">type</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">type</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">static</span> <span class="n">type</span> <span class="n">mid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
	<span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1u</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">mid</span><span class="p">))</span> <span class="k">return</span> <span class="n">rfind</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">return</span> <span class="n">rfind</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="左二分模型">左二分模型</h5> <p>此模型对应的是「右子序列中的元素满足条件」。因为二分的解的意义在这个模型中特化为「右子序列中最左边的元素」。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">type</span> <span class="p">&gt;</span>
<span class="n">type</span> <span class="nf">lfind</span><span class="p">(</span><span class="k">const</span> <span class="n">type</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">type</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">static</span> <span class="n">type</span> <span class="n">mid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
	<span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1u</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">mid</span><span class="p">))</span> <span class="k">return</span> <span class="n">lfind</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">return</span> <span class="n">lfind</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="二分的编码细节">二分的编码细节</h5> <ul> <li>两个模型中分治时传递参数不同，是由其二分意义决定的。</li> <li>在\(check(mid) = true\)这个分支中，需要保证子结构的范围一定小于本层范围，否则会造成死循环。 <ul> <li>\(rfind\)中要避免\(mid = l\)，则\(mid = (l + r + 1) \gg 1u\)。</li> <li>\(lfind\)中要避免\(mid + 1 = r\)，则\(mid = (l + r - 1)\gg 1u\)。</li> </ul> </li> </ul> <h3 id="封装上下界函数upper_bound-lower_bound">封装：上下界函数\(upper\_bound,\ lower\_bound\)</h3> <p>根据上面的分析，我们知道二分算法一定是可以得到解的，但一个序列不一定是可以二分的。求解问题的流程应该是：</p> <p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiZ3JhcGggTFJcbnF1ZXN0aW9uW-W6j-WIl10gLS0-IGp1ZGdle-aYr-WQpuWPr-iiq-S6jOWIhn1cbmp1ZGdlIC0tPnzlj6_ooqvkuozliIZ8YmZpbmQo5LqM5YiGKVxuYmZpbmQgLS0-IGFucygo6KejKSlcbmp1ZGdlIC0tPnzkuI3lj6_ooqvkuozliIZ8bm9hbnMoKOaXoOinoykpIiwibWVybWFpZCI6eyJ0aGVtZSI6ImRlZmF1bHQifX0"></p> <p>但是对于一个封装好的函数，被调用是一定要执行的，那么无解的情况就以返回一个指向有效序列之外的地址代表，和\(STL\)的规范一致，无解时返回边界\(r\)。此时求解问题的流程就变为：</p> <p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoiZ3JhcGggTFJcbnF1ZXN0aW9uW-W6j-WIl10gLS0-fOS6jOWIhnwgYWRkcmVzc1vlnLDlnYBdXG5hZGRyZXNzIC0tPiBqdWRnZXvmmK_lkKbmnInmlYh9XG5qdWRnZSAtLT585pyJ5pWI5Zyw5Z2AfCBhbnMoKOinoykpXG5qdWRnZSAtLT585peg5pWI5Zyw5Z2AfCBub2Fucygo5peg6KejKSkiLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9fQ"></p> <p>下面对比一下上下界函数和二分模型的区别与联系。</p> <p><img src="/assets/images/algorithm/basic/bfind_bound_diff.svg" alt="bfind_bound"></p> <p><em>注意上下界函数中\(comp\)的参数顺序不同。</em></p> <h2 id="前缀和与差分">前缀和与差分</h2> <p>前缀和与差分都是一种预处理的手段，用于优化区间操作：前缀和优化区间求和的速度；差分优化区间更新（特指区间中素有元素加上一个数）的速度。</p> <h3 id="前缀和">前缀和</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">type</span> <span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">prefix</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">type</span> <span class="n">ar</span><span class="p">[</span><span class="n">maxn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">type</span> <span class="n">solve</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ar</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="n">ar</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="差分">差分</h3> <p>差分其实就是前缀和的逆。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">type</span> <span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">fidif</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">type</span> <span class="n">ar</span><span class="p">[</span><span class="n">maxn</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
	<span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
			<span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">modify</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">type</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="n">ar</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c</span><span class="p">,</span> <span class="n">ar</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">c</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="多维前缀和与差分">多维前缀和与差分</h3> <ul> <li>
<strong>初始化</strong>：先后分别对各个维度做一维的初始化。</li> <li>
<strong>操作</strong>：多维前缀和的区间求和与多维差分的区间更新都是对「容斥原理」的应用。</li> </ul> <h2 id="常用排序及其基本应用">常用排序及其基本应用</h2> <p>这里说一说两个排序算法：快排和并归。它们都较好的运用了双指针思想，是应用比较多且思想比较好的排序算法。先来看看两个算法在几个方面的对比：</p> <table> <thead> <tr> <th style="text-align: right"> </th> <th style="text-align: center">快速排序</th> <th style="text-align: center">并归排序</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">是否稳定</td> <td style="text-align: center">不稳定</td> <td style="text-align: center">稳定</td> </tr> <tr> <td style="text-align: right">流程</td> <td style="text-align: center">确定分界值，处理本层，得到分界点，分治子结构</td> <td style="text-align: center">确定分界点，分治子结构，处理本层</td> </tr> <tr> <td style="text-align: right">外部空间</td> <td style="text-align: center">不需要</td> <td style="text-align: center">需要一倍外部空间</td> </tr> </tbody> </table> <p>可以发现快速排序是「自上而下」的排序，而并归是「自下而上」的，所以基本上所有和排序相关的附加操作都可以通过这两个算法的流程的实现。</p> <h3 id="快速排序">快速排序</h3> <p>我们以将一个序列从小到大排序为例，解释一下快排的核心思想：<strong>对于给定的一个序列\([l, r)\)，若对于\(\forall mid\in [l + 1, r - 1)\)，都满足序列\([l, mid)\)中的最大值不大于序列\([mid, r)\)中的最小值，则可以确定序列\([l, r)\)是从小到大排序完成的。</strong></p> <p>而快排所做的事情就是：<strong>对于一个给定的序列\([l, r)\)，移动其中部分元素使得\(\exists mid\in [l + 1, r - 1)\)使得序列\([l, mid)\)中的最大值不大于序列\([mid, r)\)中的最小值，然后分治这两个子序列。</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">type</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Comp</span> <span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">ksort</span><span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">Comp</span> <span class="n">cmp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">type</span> <span class="n">x</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="p">[(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1u</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cmp</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="o">++</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">))</span> <span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="o">--</span><span class="n">j</span><span class="p">]))</span> <span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="n">swap</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">ksort</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cmp</span><span class="p">);</span>
	<span class="n">ksort</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cmp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>可以注意到\(i, j\)是等价的，都可以作为序列的划分点。实现细节上略需注意：</p> <ul> <li>一般区间中待比较的元素\(x\)有这几种选法：最左/右边的元素，中间元素，随机元素。对于随机数据，它们的平均时间复杂度是一样的，但若初始序列为完全相反的排序状态，则选用最左/右边的元素将达到最坏时间复杂度。对于中间元素和随机元素，一般选用实现较为简单的中间元素。</li> <li>以\(i\)作为划分点时，\(x\)不能取用当前区间最左边元素，否则将有可能造成死循环。一般实现为\(x = v[(l+r)\gg 1u]\)。</li> <li>同理，\(j\)作为划分点时，\(x = v[(l+r-1)\gg 1u]\)。</li> <li>\(Comp\)可以为\(less, greater\)。</li> </ul> <h4 id="查找第k小大的数">查找第k小/大的数</h4> <p>若划分点所在位置元素的值与待比较元素\(x\)的值相等，则划分点所在位置的元素在排序完成的整个序列中位置已经确定为该位置。下面以\(i\)为划分点为例：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="k">return</span> <span class="nf">seek</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">cmp</span><span class="p">);</span>
<span class="k">else</span> <span class="k">return</span> <span class="nf">seek</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">cmp</span><span class="p">);</span>
</code></pre></div></div> <h3 id="并归排序">并归排序</h3> <p>并归排序的核心思想较为容易理解：<strong>对于一个给定的序列\([l, r)\)，通过中间点\(mid\)将其划分为\([l, mid), [mid, r)\)两个子序列并分治使子序列排序完成，然后合并它们。</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">type</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Comp</span> <span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">msort</span><span class="p">(</span><span class="n">type</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">Comp</span> <span class="n">cmp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">static</span> <span class="n">type</span> <span class="n">bak</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1u</span><span class="p">;</span>
	<span class="n">msort</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">cmp</span><span class="p">);</span>
	<span class="n">msort</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cmp</span><span class="p">);</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmp</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="n">bak</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
		<span class="k">else</span> <span class="n">bak</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">)</span> <span class="n">bak</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="n">bak</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">l</span><span class="p">)</span> <span class="n">v</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">bak</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div> <p>需要注意：</p> <ul> <li>由于并归排序的分治在本层操作之前，所以\(mid\)的类型一定不能是\(static\)。</li> <li>\(Comp\)可以为\(less\_equal, greater\_equal\)。</li> </ul> <h4 id="计算正逆序对">计算正/逆序对</h4> <p>对于一个给定的序列\([l, r)\)，可以把其中的有序数对\(\{e, u\}\)分为3种：</p> <ul> <li>\(e, u\in [l, mid)\)，这部分正/逆序对由分治\([l, mid)\)时求得。</li> <li>\(e, u\in [mid, r)\)，这部分正/逆序对由分治\([mid, r)\)时求得。</li> <li>\(e\in [l, mid), u\in [mid, r)\)，这部分由本层并归时求得。</li> </ul> <p>显然第3种情况是需要处理的重点，我们以分析从小到大排序的正/逆序对的计算为例：</p> <p><img src="/assets/images/algorithm/basic/digit_pair.svg" alt="digitpair"></p> <ul> <li>若\(v[i]\leqslant v[j]\)，又\(v[j]\leqslant v[j+1]\leqslant \cdots\leqslant v[r-1]\)，所以有\(\forall x\in [j, r)\)满足\(v[i]\leqslant v[x]\)，共确定了\(r - j\)个正序对。</li> <li>若\(v[i] &gt; v[j]\)，又\(v[i]\leqslant v[i+1]\leqslant\cdots\leqslant v[mid-1]\)，所以有\(\forall x\in [i, mid)\)满足\(v[x] &gt; v[j]\)，共确定了\(mid-i\)个逆序对。</li> </ul> <h2 id="位运算与二进制">位运算与二进制</h2> <h3 id="快速枚举组合">快速枚举组合</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="n">j</span> <span class="o">&amp;</span> <span class="mi">1u</span><span class="p">)</span>
            <span class="p">...</span>
</code></pre></div></div> <h3 id="快速幂与龟速乘">快速幂与龟速乘</h3> <p>快速幂是将\(O(n)\)的乘方通过\(O(\log n)\)的乘法实现；龟速乘是将\(O(1)\)的乘法通过\(O(\log n)\)的加法实现。龟速乘虽然慢，但是对于大数相乘别无他法。</p> <h4 id="快速幂">快速幂</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">llong</span> <span class="nf">qpow</span><span class="p">(</span><span class="n">llong</span> <span class="n">x</span><span class="p">,</span> <span class="n">llong</span> <span class="n">a</span><span class="p">,</span> <span class="n">llong</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">static</span> <span class="n">llong</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;</span> <span class="mi">1u</span><span class="p">)</span> <span class="p">(</span><span class="n">ret</span> <span class="o">*=</span> <span class="n">x</span><span class="p">)</span> <span class="o">%=</span> <span class="n">mod</span><span class="p">;</span>
		<span class="p">(</span><span class="n">x</span> <span class="o">*=</span> <span class="n">x</span><span class="p">)</span> <span class="o">%=</span> <span class="n">mod</span><span class="p">;</span>
		<span class="n">a</span> <span class="o">&gt;&gt;=</span> <span class="mi">1u</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="龟速乘">龟速乘</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ullong</span> <span class="nf">smul</span><span class="p">(</span><span class="n">ullong</span> <span class="n">a</span><span class="p">,</span> <span class="n">ullong</span> <span class="n">b</span><span class="p">,</span> <span class="n">ullong</span> <span class="n">mod</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">static</span> <span class="n">ullong</span> <span class="n">ret</span><span class="p">;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="mi">1u</span><span class="p">)</span> <span class="p">(</span><span class="n">ret</span> <span class="o">+=</span> <span class="n">a</span><span class="p">)</span> <span class="o">%=</span> <span class="n">mod</span><span class="p">;</span>
		<span class="p">(</span><span class="n">a</span> <span class="o">&lt;&lt;=</span> <span class="mi">1u</span><span class="p">)</span> <span class="o">%=</span> <span class="n">mod</span><span class="p">;</span>
		<span class="n">b</span> <span class="o">&gt;&gt;=</span> <span class="mi">1u</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="字符串哈希">字符串哈希</h2> <p>这里介绍一种常用且很著名的字符串哈希方法——<strong>BKHDHash</strong>。这种哈希方法是将字符串理解为一个\(p\)进制的数。由于我们需要区间哈希，所以要借助前缀和的思想。根据经验，\(p\)取值为131或1331，字符的值映射为对应的ASCII码值，区间哈希值对\(2^{64}\)取模时冲突率极小。直接使用\(unsigned\ long\ long\)类型存储，溢出即取模。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">strhash</span> <span class="p">{</span>
	<span class="n">string</span> <span class="n">s</span><span class="p">;</span>
	<span class="n">ullong</span> <span class="n">ar</span><span class="p">[</span><span class="n">maxn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{};</span>
	<span class="n">ullong</span> <span class="n">bin</span><span class="p">[</span><span class="n">maxn</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span><span class="mi">1ULL</span><span class="p">};</span>
	<span class="k">const</span> <span class="n">ullong</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">131ULL</span><span class="p">;</span>
<span class="nl">public:</span>
	<span class="k">explicit</span> <span class="n">string_hash</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">)</span><span class="o">:</span><span class="n">s</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">str</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ar</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">base</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">bin</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">base</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ullong</span> <span class="n">hash</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ar</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="n">ar</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">*</span> <span class="n">bin</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> </div> </div> </div> </div> </div> <footer> <div class="container"> <div class="row"> <div class="col-lg-8"> <p>Mooyyu Crab.'s Blog <i class="fa fa-heart text-danger" aria-hidden="true"></i>. Check out <a href="//github.com/mooyyu/mooyyu.github.io" target="_blank">Github Project <i class="fa fa-github-alt" aria-hidden="true"></i></a>.<br> The contents of this website are © 2021 under the terms of the <a href="//www.gnu.org/licenses/gpl-3.0.txt" target="_blank">GPLv3</a> License.</p> </div> <div class="col-lg-4"> <div class="pull-right"> <a href="#top" data-proofer-ignore> Back to top <i class="fa fa-level-up" aria-hidden="true"></i></a> </div> </div> </div> </div> </footer> <div style="width: 100%; overflow-x: hidden;"> <canvas class="fireworks" style="position:fixed;left:0;top:0;z-index:99999999;pointer-events:none;"></canvas> </div> <script>
  MathJax = {
    options: {
      enableMenu: false
    }
  };
</script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js"></script> <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-128176907-1', {
          'cookieDomain': 'mooyyu.github.io',
          'siteSpeedSampleRate': 80
      });

      ga('require', 'displayfeatures');
      ga('send', 'pageview');
    </script> </body> </html>
