<!DOCTYPE html>
<html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="flattr:id" content="e7nqg5"> <title>图论浅谈之最短路 | Mooyyu Crab.</title> <meta name="generator" content="Jekyll v3.9.0"> <meta property="og:title" content="图论浅谈之最短路"> <meta name="author" content="mooyyu"> <meta property="og:locale" content="en_US"> <meta name="description" content="传统算法中的最短路问题解读"> <meta property="og:description" content="传统算法中的最短路问题解读"> <link rel="canonical" href="https://mooyyu.github.io/docs/algorithm/Graph-shortest_path.html"> <meta property="og:url" content="https://mooyyu.github.io/docs/algorithm/Graph-shortest_path.html"> <meta property="og:site_name" content="Mooyyu Crab."> <meta property="og:type" content="article"> <meta property="article:published_time" content="2020-03-15T00:00:00+00:00"> <script type="application/ld+json">
{"headline":"图论浅谈之最短路","dateModified":"2020-03-15T00:00:00+00:00","datePublished":"2020-03-15T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mooyyu.github.io/docs/algorithm/Graph-shortest_path.html"},"author":{"@type":"Person","name":"mooyyu"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://mooyyu.github.io/assets/images/logo/mooyyu/m.png"},"name":"mooyyu"},"description":"传统算法中的最短路问题解读","url":"https://mooyyu.github.io/docs/algorithm/Graph-shortest_path.html","@type":"BlogPosting","@context":"https://schema.org"}</script> <link rel="icon" href="/assets/favicon.ico"> <link rel="stylesheet" href="/assets/stylesheets/main.css"> <!--[if lt IE 9]><script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script> <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script><![endif]--> <script src="/assets/javascript/head.min.js"></script> <script type="text/javascript">

      /**
       * As Github pages do not support https for custom domains
       * this is the current best workaround for #18.
       */
      var domains  = [ 'mooyyu.github.io', 'localhost', '127.0.0.1' ];
      var pathname = location.pathname.replace(/^\/Mooyyu Crab.'s Github Page/, '')
      if (domains.indexOf(window.location.hostname) == -1)
        window.top.location.href = 'https://mooyyu.github.io' + pathname;

      /**
       * Another ugly workaround trying to improve UX reported by #35
       */
      if (location.protocol != 'https:' && window.location.hostname == 'mooyyu.github.io')
        location.href = 'https:' + window.location.href.substring(window.location.protocol.length);

      /**
       * Improves overall speed by loading javascript and css resources in parallel
       * with the main page.
       */
      head.load(
          "/assets/stylesheets/font-awesome.min.css",

          "/assets/javascript/jquery-2.2.1.min.js",
          "/assets/javascript/jquery-ui.min.js",
          "/assets/javascript/bootstrap.min.js",
          "/assets/javascript/tocify.min.js",
          "/assets/javascript/custom.js",

          "/assets/javascript/sheetrock.min.js",
          "/assets/javascript/cookieconsent.min.js",
          "/assets/javascript/pop.min.js"
      );

      head.ready(function() {
        window.cookieconsent_options = {
          "message":"This site use cookies to ensure you get the best experience on the website",
          "dismiss": "Got it!", "learnMore": "More info", "link":"", "theme": "dark-bottom"
        };
        $("body").on('click', '[data-stopPropagation]', function (e) {
          e.stopPropagation();
        });
      });
    </script> </head> <body role="document"> <nav class="navbar navbar-default navbar-fixed-top custom-no-margin"> <div class="container"> <div class="navbar-header"> <a href="/" class="navbar-brand" style="color: slategrey;"> Mooyyu Crab.'s Blog </a> <img id="daynite" src="/assets/images/btn-night.svg" alt="Dark Mode" width="32" height="32"> <button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#navbar-main"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> </div> <div class="navbar-collapse collapse" id="navbar-main"> <ul class="nav navbar-nav"> <li><a href="/whoami/">WHO AM I? </a></li> <li class="dropdown siteindex"> <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="navbar-documentation">Site Index <span class="caret"></span></a> <ul class="dropdown-menu"> <li class="dropdown dropdown-submenu algorithm"> <a href="#" class="dropdown-toggle" data-toggle="dropdown" data-stoppropagation="true" id="navbar-sub-algorithm">Algorithm</a> <ul class="dropdown-menu"> <li><a href="/meta/algorithm/"> All documents </a></li> <li class="divider"> <li><a href="/docs/algorithm/Math-1.html">算法竞赛简单数论知识(一)</a></li> <li><a href="/docs/algorithm/DP-knapsack.html">动态规划: 背包问题 (一)</a></li> <li><a href="/docs/algorithm/Graph-shortest_path.html">图论浅谈之最短路</a></li> <li><a href="/docs/algorithm/DP-linear.html">动态规划入门之线性极值模型</a></li> <li><a href="/docs/algorithm/DS-1.html">算法竞赛简单数据结构(一)</a></li> <li><a href="/docs/algorithm/Graph-segment_tree_scan.html">线段树之扫描线浅谈</a></li> <li><a href="/docs/algorithm/basic.html">基础算法杂谈</a></li> </ul> </li> <li class="dropdown dropdown-submenu oicode"> <a href="#" class="dropdown-toggle" data-toggle="dropdown" data-stoppropagation="true" id="navbar-sub-oicode">OI-code</a> <ul class="dropdown-menu"> <li><a href="/meta/oicode/"> All documents </a></li> <li class="divider"> <li><a href="/docs/oicode/B1.html"><strong>B1</strong>: 前缀和与差分</a></li> <li><a href="/docs/oicode/B2.html"><strong>B2</strong>: 快速组合</a></li> <li><a href="/docs/oicode/B3.html"><strong>B3</strong>: 二分查找</a></li> <li><a href="/docs/oicode/B4-add.html"><strong>B4</strong>: 高精度加法</a></li> <li><a href="/docs/oicode/B4-div.html"><strong>B4</strong>: 高精度除法</a></li> <li><a href="/docs/oicode/B4-multi.html"><strong>B4</strong>: 高精度乘法</a></li> <li><a href="/docs/oicode/B4-sub.html"><strong>B4</strong>: 高精度减法</a></li> <li><a href="/docs/oicode/D1.html"><strong>D1</strong>: 单调栈</a></li> <li><a href="/docs/oicode/D2.html"><strong>D2</strong>: 单调队列</a></li> <li><a href="/docs/oicode/D3.html"><strong>D3</strong>: Spare Table</a></li> <li><a href="/docs/oicode/D4.html"><strong>D4</strong>: 字典树</a></li> <li><a href="/docs/oicode/D5.html"><strong>D5</strong>: 并查集</a></li> <li><a href="/docs/oicode/D6-rc.html"><strong>D6</strong>: 树状数组-限定区间计数</a></li> <li><a href="/docs/oicode/D6-surs.html"><strong>D6</strong>: 树状数组-单点更新区间求和</a></li> <li><a href="/docs/oicode/D7-basic.html"><strong>D7</strong>: 线段树-基础</a></li> <li><a href="/docs/oicode/G1.html"><strong>G1</strong>: 二分图-判定</a></li> <li><a href="/docs/oicode/G2.html"><strong>G2</strong>: 二分图-最大匹配</a></li> <li><a href="/docs/oicode/G3.html"><strong>G3</strong>: Astar k短路 on matrix</a></li> <li><a href="/docs/oicode/G4.html"><strong>G4</strong>: 拓扑排序</a></li> <li><a href="/docs/oicode/G5.html"><strong>G5</strong>: 连通无环无向图的重心</a></li> <li><a href="/docs/oicode/G6.html"><strong>G6</strong>: MST-Kruskal</a></li> <li><a href="/docs/oicode/G7.html"><strong>G7</strong>: MST-Prim</a></li> <li><a href="/docs/oicode/G8.html"><strong>G8</strong>: ShortestPath-BellmanFord</a></li> <li><a href="/docs/oicode/G9.html"><strong>G9</strong>: ShortestPath-Dijkstra</a></li> <li><a href="/docs/oicode/G9-hopt.html"><strong>G9</strong>: ShortestPath-Dijkstra Heap OPT</a></li> <li><a href="/docs/oicode/G10.html"><strong>G10</strong>: ShortestPath-SPFA</a></li> <li><a href="/docs/oicode/G11.html"><strong>G11</strong>: ShortestPath-Floyd</a></li> <li><a href="/docs/oicode/M1.html"><strong>M1</strong>: 快速幂与龟速乘</a></li> <li><a href="/docs/oicode/M2.html"><strong>M2</strong>: 欧几里得-最大公约数</a></li> <li><a href="/docs/oicode/M2-ft.html"><strong>M2</strong>: EX欧几里得-翡蜀定理</a></li> <li><a href="/docs/oicode/M2-lce.html"><strong>M2</strong>: EX欧几里得-线性同余方程</a></li> <li><a href="/docs/oicode/M2-mi.html"><strong>M2</strong>: EX欧几里得-乘法逆元</a></li> <li><a href="/docs/oicode/M3-flt.html"><strong>M3</strong>: 费马小定理-乘法逆元</a></li> <li><a href="/docs/oicode/M4.html"><strong>M4</strong>: 分解质因数</a></li> <li><a href="/docs/oicode/M4-euler.html"><strong>M4</strong>: 分解质因数-欧拉函数</a></li> <li><a href="/docs/oicode/M4-prc.html"><strong>M4</strong>: 分解质因数-多数乘积约数计数</a></li> <li><a href="/docs/oicode/M4-prs.html"><strong>M4</strong>: 分解质因数-多数乘积约数求和</a></li> <li><a href="/docs/oicode/M5.html"><strong>M5</strong>: 欧拉筛</a></li> <li><a href="/docs/oicode/M5-ps.html"><strong>M5</strong>: 欧拉筛-质数筛</a></li> <li><a href="/docs/oicode/M6.html"><strong>M6</strong>: 埃氏筛-质数筛</a></li> <li><a href="/docs/oicode/M7.html"><strong>M7</strong>: Stein算法-最大公约数</a></li> <li><a href="/docs/oicode/M8.html"><strong>M8</strong>: 矩阵乘法与快速幂</a></li> <li><a href="/docs/oicode/O1.html"><strong>O1</strong>: 快速排序</a></li> <li><a href="/docs/oicode/O2.html"><strong>O2</strong>: 并归排序</a></li> <li><a href="/docs/oicode/S1.html"><strong>S1</strong>: KMP</a></li> <li><a href="/docs/oicode/S2.html"><strong>S2</strong>: 字符串哈希</a></li> </ul> </li> </ul> </li> <li class="dropdown"> <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="navbar-algorithm">传统算法 <span class="caret"></span></a> <ul class="dropdown-menu"> <li><a href="/docs/algorithm/basic">基础算法杂谈</a></li> <li class="divider"> <li><a href="/docs/algorithm/DS-1">算法竞赛简单数据结构(一)</a></li> <li class="divider"> <li><a href="/docs/algorithm/DP-knapsack">动态规划:背包问题(一)</a></li> <li><a href="/docs/algorithm/DP-linear">动态规划入门之线性极值模型</a></li> <li class="divider"> <li><a href="/docs/algorithm/Graph-shortest_path">图论浅谈之最短路</a></li> <li><a href="/docs/algorithm/Graph-segment_tree_scan">线段树之扫描线浅谈</a></li> <li class="divider"> <li><a href="/docs/algorithm/Math-1">算法竞赛简单数论知识(一)</a></li> </ul> </li> <li class="dropdown"> <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="navbar-math">数学笔记 <span class="caret"></span></a> <ul class="dropdown-menu"> <li><a>🦉即将上线</a></li> </ul> </li> <li class="dropdown"> <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="navbar-ai">AI笔记 <span class="caret"></span></a> <ul class="dropdown-menu"> <li><a>🦉即将上线</a></li> </ul> </li> </ul> <ul class="nav navbar-nav navbar-right visible-lg-block"> </ul> </div> </div> </nav> <div class="container" role="main"> <div class="row"> <div class="col-lg-3 col-md-4 visible-lg-block visible-md-block custom-no-padding"> <div class="custom-fixed-sidebar"> <div id="toc"></div> </div> </div> <div class="col-lg-9 col-md-8 custom-bg-white"> <div class="row"> <div class="col-md-12 custom-article"> <p class="text-right pull-right visible-lg-block hidden-print small custom-pt25"> <a href="//github.com/mooyyu" target="_blank" data-toggle="tooltip" data-placement="bottom" title="Visit mooyyu's profile on Github"><img class="avatar avatar-small" alt="mooyyu" width="30" height="30" data-proofer-ignore="true" src="https://avatars3.githubusercontent.com/mooyyu?v=3&s=30" srcset="https://avatars3.githubusercontent.com/mooyyu?v=3&s=30 1x, https://avatars3.githubusercontent.com/mooyyu?v=3&s=60 2x, https://avatars3.githubusercontent.com/mooyyu?v=3&s=90 3x, https://avatars3.githubusercontent.com/mooyyu?v=3&s=120 4x"></a> </p> <h1 class="custom-article-header">图论浅谈之最短路</h1> <p class="text-right pull-right small">15 March 2020</p> <p class="small"> 传统算法中的最短路问题解读 </p> <p>最短路问题是传统算法竞赛中图论的最常考察的问题，也是内容相对多的部分。本文详细讨论最短路的各基础算法以及常用的最短路模型和拓展。本文偏向于应用与细节而非原理。</p> <hr> <h2 id="本文主要内容">本文主要内容</h2> <ul> <li>本文中最短路用到的常用术语</li> <li>全源全汇最短路与Floyd算法</li> <li>单源最短路 <ul> <li>带权最短路下的基础算法 <ul> <li>带权最短路问题图的存储方法和注意事项</li> <li>适用稠密正权图的朴素的Dijkstra算法</li> <li>适用稀疏正权图的堆优化的Dijkstra算法</li> <li>SPFA算法</li> </ul> </li> <li>各算法的全汇最短路与单汇最短路</li> <li>BFS适用的最短路问题 <ul> <li>BFS如何求解特定的最短路问题</li> <li>BFS适用的最短路模型 <ul> <li>最小步数模型</li> <li>最少转换模型 <ul> <li>使用双向BFS算法优化</li> <li>使用A*算法优化</li> </ul> </li> </ul> </li> </ul> </li> <li>单源最短路的各种拓展 <ul> <li>边数限制为k的最短路与Bellman-Ford算法</li> <li>多个可选源点最短路</li> <li>正权图上的次短路与Dijkstra算法</li> <li>k短路与A*算法</li> <li>维护路径最短路 <ul> <li>最小字典序路径</li> <li>所有路径</li> </ul> </li> </ul> </li> </ul> </li> <li>其他 <ul> <li>SPFA算法与判断负环</li> </ul> </li> </ul> <h2 id="本文中最短路用到的常用术语">本文中最短路用到的常用术语</h2> <table> <thead> <tr> <th style="text-align: right">术语</th> <th>含义</th> <th>表示</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">源点、汇点</td> <td>对于一条最短路的起点、终点</td> <td>\(source、sink\)</td> </tr> <tr> <td style="text-align: right">最短距离</td> <td>点\(i\)到点\(j\)的最短距离、源点到点\(k\)的最短距离</td> <td>\(d(i, j)、dis(k)\)</td> </tr> <tr> <td style="text-align: right">三角不等式</td> <td>从点\(i\) 到\(j\) 的直接距离不会大于途经的任何其它点\(k\)的距离</td> <td>\(d(i, j)\leqslant d(i, k) + d(k, j)\)</td> </tr> <tr> <td style="text-align: right">松弛操作</td> <td>利用三角不等式，使用中间点\(k\)更新点\(i\)到\(j\)的直接距离，一般\(i\)指源点</td> <td>\(relax(k, j)\)</td> </tr> <tr> <td style="text-align: right">不连通</td> <td>使用一个相对于图中数据大很多的值作为两点间距离表示不连通</td> <td>\(INF\)</td> </tr> <tr> <td style="text-align: right">节点集、边集</td> <td>构成图的所有节点的集合、边的集合</td> <td>\(Vertex、Edge\)</td> </tr> <tr> <td style="text-align: right">出点、入点</td> <td>对于一条有向边的指出点、指向点</td> <td>\(e、u\)</td> </tr> </tbody> </table> <h2 id="全源全汇最短路与floyd算法">全源全汇最短路与Floyd算法</h2> <p>Floyd算法是一个很优美的算法，可以求解任意起点至任意终点的最短路。运用了动态规划的思想。</p> \[\begin{aligned} definition&amp;\\ &amp;f(i, j)\text{ express the shortest length of the path from point i to point j}\\ &amp;dis(i, j)\text{ express the length of the path from point i to point j}\\ request&amp;\\ &amp;\forall i, j\in Vertex, f(i, j)\\ state\ trasition&amp;\\ &amp;f(i, j) = \begin{cases} f(i, j)\\ \{f(i, k) + f(k, j)\mid k\in Vertex\} \end{cases}\\ &amp;state\ division:\quad f(i, j)\text{ is unrelaxed or releaxed by point k}\\ optimization&amp;\\ &amp;none\\ solution&amp;\\ &amp;loop\quad k\ in\ Vertex\\ &amp;\hphantom{loop\quad}loop\quad i\ in\ Vertex\\ &amp;\hphantom{loop\quad loop\quad}loop\quad j\ in\ Vertex\\ &amp;\hphantom{loop\quad loop\quad loop\quad}relax(k, j)\ about\ i\\ \end{aligned}\] <p>Floyd算法求解全源全汇最短路的细节注意点</p> <ul> <li>由于求解的是任意两点间的最短路，所以适合使用邻接矩阵存储图的结构</li> <li>求解前构图的过程分为初始化与输入 <ul> <li>初始化时注意\(d(i, j)\begin{cases} INF,&amp;i\not = j\\0,&amp;i = j \end{cases}\)，为下面的输入去重做准备</li> <li>由于邻接矩阵结构中两点间仅能存储一个距离，所以输入要处理重边问题</li> </ul> </li> <li>由于在负权图中\(INF\)可以被负权边松弛成功，所以要提前判断\(d(i, k)\)和\(d(k, j)\)不是\(INF\)</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">type</span> <span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">FP</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="nl">public:</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">INF</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span> <span class="n">type</span> <span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">1u</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ar</span><span class="p">[</span><span class="n">maxn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">maxn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{};</span>
	<span class="k">explicit</span> <span class="n">FP</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fill</span><span class="p">(</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>
			<span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">solve</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span>
					<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">ar</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span>
							<span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">ar</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="单源最短路">单源最短路</h2> <p>单源最短路是最短路问题中内容最多，考察最多最杂的部分。可以分为带权单源最短路、BFS适用的最短路问题以及以他们为基础进行拓展的特殊问题。一般考察最多的是单源单汇最短路，但大部分算法可求单源全汇最短路问题，也有针对单汇进行优化的方法和只能求解单汇最短路问题的特殊算法。</p> <h3 id="带权最短路的基础算法">带权最短路的基础算法</h3> <p>一般可以求解带权单源最短路问题的算法有Dijkstra算法及其堆优化的算法、Bellman-Ford算法以及基于其的SPFA算法。由于一般问题中Bellman-Ford算法不存在优越性，故这里省去，此算法将在后文的拓展最短路问题中讲到。</p> <p>对于各最短路算法我的分析思路为：确定使用的数据结构(data structure)——求解初始化(initialization)——核心算法(core algorithm)，我称之为\(DIC\)分析法。在此之前，先说一说有关带权图存图的问题。</p> <h4 id="带权最短路问题图的存储方法和注意事项">带权最短路问题图的存储方法和注意事项</h4> <p>带权图的存储总的来说有三种结构：边集、邻接矩阵和邻接表。边集较为简单，使用结构体数组即可。邻接矩阵适用于稠密图，邻接表适用于稀疏图。其中邻接表有两种实现方式：向量\(vector\)和链式前向星<sup id="fnref:link_astar" role="doc-noteref"><a href="#fn:link_astar" class="footnote">1</a></sup>，由于内存分配的耗时是仅和分配次数成正比的，所以链式前向星具有绝对优势，在图论问题中都使用链式前向星实现连接表。</p> <p>邻接矩阵存图存在如下需注意的事项</p> <ul> <li>无法存储重边，只能在初始化和输入时处理此问题，其中初始化时\(d(i, j)\begin{cases} INF,&amp;i\not = j\\0,&amp;i = j \end{cases}\)</li> <li>存储无向图时，要把每条无向边转为两条对应的有向边</li> </ul> <p>链式前向星、边集存图存在如下需注意的事项</p> <ul> <li>存储无向图时，不仅要转化边，存储空间也需要扩大一倍</li> </ul> <p>各基础算法的存图结构如下：</p> <table> <thead> <tr> <th style="text-align: center">算法名称</th> <th style="text-align: center">存图结构</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">适用稠密图的朴素版Dijkstra算法</td> <td style="text-align: center">邻接矩阵</td> </tr> <tr> <td style="text-align: center">适用稀疏图的堆优化版Dijkstra算法</td> <td style="text-align: center">链式前向星</td> </tr> <tr> <td style="text-align: center">SPFA算法</td> <td style="text-align: center">链式前向星</td> </tr> <tr> <td style="text-align: center">用于求解第k短路的Bellman-Ford算法</td> <td style="text-align: center">边集</td> </tr> </tbody> </table> <h4 id="适用稠密正权图的朴素的dijkstra算法">适用稠密正权图的朴素的Dijkstra算法</h4> <blockquote> <p>时间复杂度：\(O(n^2)\)</p> <p>一句话核心思想：每次选取余下的结点中最近的一个尝试松弛其出边。</p> </blockquote> \[\begin{aligned} data\ structure&amp;\\ &amp;数组dis：源点到各点的最短路径\\ &amp;集合vis：不满足状态「最短路确定，向后完成松弛操作」的结点的集合\\ initialization&amp;\\ &amp;dis(e) = \begin{cases} INF,&amp;e \not = source\\ 0,&amp;e = source \end{cases}\\ &amp;push\ \forall e\in Vertex\ into\ vis\\ core\ algorithm&amp;\\ &amp;loop\quad n - 1\ times\\ &amp;\hphantom{loop\quad}find\ cur\in vis, \forall e\in vis,dis(cur)\leqslant dis(e)\\ &amp;\hphantom{loop\quad}delete\ cur\ from\ vis\\ &amp;\hphantom{loop\quad}relax(cur, u), u\in vis\\ \end{aligned}\] <p>注意上述过程中\(cur\)仅对属于集合\(vis\)的结点进行松弛，并不违背核心思想，因为对不属于集合\(vis\)的结点尝试松弛没有意义（这些结点的最短路已确定）。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">type</span> <span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">SPD_Dijkstra</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vis</span><span class="p">;</span>
<span class="nl">public:</span>
	<span class="n">type</span> <span class="n">INF</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="mi">1u</span><span class="p">;</span>
	<span class="n">type</span> <span class="n">dis</span><span class="p">[</span><span class="n">maxn</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">{};</span>
	<span class="n">type</span> <span class="n">ar</span><span class="p">[</span><span class="n">maxn</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">maxn</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">{};</span>
	<span class="k">explicit</span> <span class="n">SPD_Dijkstra</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">fill</span><span class="p">(</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">solve</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">source</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">vis</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">fill</span><span class="p">(</span><span class="n">dis</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dis</span><span class="o">+</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>
		<span class="n">dis</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cur</span> <span class="o">=</span> <span class="o">*</span><span class="n">vis</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
			<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">vis</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dis</span><span class="p">[</span><span class="n">cur</span><span class="p">])</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">vis</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">vis</span><span class="p">)</span> <span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dis</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dis</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">+</span> <span class="n">ar</span><span class="p">[</span><span class="n">cur</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="适用稀疏正权图的堆优化的dijkstra算法">适用稀疏正权图的堆优化的Dijkstra算法</h4> <p>可以注意到朴素的Dijkstra算法有两个地方可以优化</p> <ul> <li>「每次选取最近的结点」这一操作可以借助小根堆维护</li> <li>只有当\(dis(cur)\)被松弛成功，\(relax(cur, u)\)才有意义</li> </ul> <blockquote> <p>时间复杂度：\(o(m\cdot \log n)\)</p> <p>核心思想和朴素版算法相同，只是实现上加了上述两个优化</p> </blockquote> \[\begin{aligned} data\ structure&amp;\\ &amp;数组dis：源点到各点的最短路径\\ &amp;集合vis：不满足状态「最短路确定，向后完成松弛操作」的结点的集合\\ &amp;小根堆srp：&lt;dis(e), e&gt;, e\in Vertex, compare\ by\ dis(e)\\ initialization&amp;\\ &amp;dis(e) = \begin{cases} INF,&amp;e \not = source\\ 0,&amp;e = source \end{cases}\\ &amp;push\ \forall e\in Vertex\ into\ vis\\ &amp;push\ source\ into\ srp\\ core\ algorithm&amp;\\ &amp;loop\quad untill\ srp\ is\ empty\\ &amp;\hphantom{loop\quad}pop\ cur\ from\ srp\\ &amp;\hphantom{loop\quad}if\quad cur\not\in vis\\ &amp;\hphantom{loop\quad if\quad}continue\ next\ loop\\ &amp;\hphantom{loop\quad}delete\ cur\ from\ vis\\ &amp;\hphantom{loop\quad}if\quad relax(cur, u), u\in vis\ is\ successful\\ &amp;\hphantom{loop\quad if\quad}push\ u\ into\ srp \end{aligned}\] <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">type</span> <span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">SPS_Dijkstra</span> <span class="p">{</span>
	<span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">pti</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="kt">bool</span> <span class="n">vis</span><span class="p">[</span><span class="n">maxn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{};</span>
	<span class="n">priority_queue</span><span class="o">&lt;</span> <span class="n">pti</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span> <span class="n">pti</span> <span class="o">&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span> <span class="n">pti</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">srp</span><span class="p">;</span>
<span class="nl">public:</span>
	<span class="k">struct</span> <span class="nc">node</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="n">ptr</span><span class="p">;</span>
		<span class="n">type</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ar</span><span class="p">[</span><span class="n">maxm</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">head</span><span class="p">[</span><span class="n">maxn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{};</span>
	<span class="k">const</span> <span class="n">type</span> <span class="n">INF</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span> <span class="n">type</span> <span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">1u</span><span class="p">;</span>
	<span class="n">type</span> <span class="n">dis</span><span class="p">[</span><span class="n">maxn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{};</span>
	<span class="k">explicit</span> <span class="n">SPS_Dijkstra</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{}</span>
	<span class="kt">void</span> <span class="n">solve</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">source</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fill</span><span class="p">(</span><span class="n">dis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dis</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>
		<span class="n">fill</span><span class="p">(</span><span class="n">vis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vis</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">priority_queue</span><span class="o">&lt;</span> <span class="n">pti</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span> <span class="n">pti</span> <span class="o">&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span> <span class="n">pti</span> <span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">().</span><span class="n">swap</span><span class="p">(</span><span class="n">srp</span><span class="p">);</span>
		<span class="n">srp</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">dis</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">source</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">srp</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">static</span> <span class="kt">int</span> <span class="n">cur</span><span class="p">;</span>
			<span class="n">cur</span> <span class="o">=</span> <span class="n">srp</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">second</span><span class="p">,</span> <span class="n">srp</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">cur</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
			<span class="n">vis</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">cur</span><span class="p">];</span> <span class="n">i</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ptr</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">])</span> <span class="p">{</span>
					<span class="k">static</span> <span class="n">type</span> <span class="n">dist</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">dist</span> <span class="o">=</span> <span class="n">dis</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">+</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dis</span><span class="p">[</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">])</span>
						<span class="n">srp</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">dis</span><span class="p">[</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">,</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">);</span>
				<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="spfa算法">SPFA算法</h4> <p>SPFA是一种很优秀的算法，根据Bellman-Ford算法发展而来。SPFA有SLF(shortest label first)和LLL(large label last)两种优化方法，但此两种优化不具有普适性，仅对特殊的图起到作用，需具体分析，故这里不作讨论。</p> <blockquote> <p>时间复杂度：平均\(O(m)\)，最坏\(O(n\cdot m)\)</p> <p>一句话核心思想：每次在新的被松弛成功的节点中选取一个向后尝试松弛其出边。</p> </blockquote> \[\begin{aligned} data\ structure&amp;\\ &amp;数组dis：源点到各点的最短路径\\ &amp;集合vis：满足状态「被松弛成功但尚未向后进行松弛操作」的结点的集合\\ &amp;队列que：&lt;e&gt;, e\in Vertex\\ initialization&amp;\\ &amp;dis(e) = \begin{cases} INF,&amp;e \not = source\\ 0,&amp;e = source \end{cases}\\ &amp;push\ source\ into\ vis\\ &amp;push\ source\ into\ que\\ core\ algorithm&amp;\\ &amp;loop\quad untill\ que\ is\ empty\\ &amp;\hphantom{loop\quad}pop\ cur\ from\ que\\ &amp;\hphantom{loop\quad}delete\ cur\ from\ vis\\ &amp;\hphantom{loop\quad}if\quad relax(cur, u),u\in \{ cur's\ successors \}\ is\ successful\\ &amp;\hphantom{loop\quad if\quad}if\quad u\not\in vis\\ &amp;\hphantom{loop\quad if\quad if\quad}push\ u\ in\ vis\\ &amp;\hphantom{loop\quad if\quad if\quad}push\ u\ in\ que \end{aligned}\] <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">type</span> <span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">SP</span> <span class="p">{</span>
	<span class="n">type</span> <span class="n">dis</span><span class="p">[</span><span class="n">maxn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{};</span>
	<span class="kt">bool</span> <span class="n">vis</span><span class="p">[</span><span class="n">maxn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{};</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">queue</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">que</span><span class="p">;</span>
<span class="nl">public:</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">INF</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span> <span class="n">type</span> <span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">1u</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="n">ptr</span><span class="p">;</span>
		<span class="n">type</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ar</span><span class="p">[</span><span class="n">maxm</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{};</span>
	<span class="kt">int</span> <span class="n">head</span><span class="p">[</span><span class="n">maxn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{};</span>
	<span class="k">explicit</span> <span class="n">SP</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{}</span>
	<span class="n">type</span> <span class="n">solve</span><span class="p">(</span><span class="kt">int</span> <span class="n">source</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fill</span><span class="p">(</span><span class="n">vis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vis</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">fill</span><span class="p">(</span><span class="n">dis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dis</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>
		<span class="n">queue</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span><span class="p">().</span><span class="n">swap</span><span class="p">(</span><span class="n">que</span><span class="p">);</span>
		<span class="n">vis</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="n">dis</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">static</span> <span class="kt">int</span> <span class="n">cur</span><span class="p">;</span>
			<span class="n">cur</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">(),</span> <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">vis</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">cur</span><span class="p">];</span> <span class="n">i</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ptr</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dis</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">+</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">dis</span><span class="p">[</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">dis</span><span class="p">[</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">dis</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">+</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">])</span> <span class="p">{</span>
						<span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">);</span>
						<span class="n">vis</span><span class="p">[</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="各算法的全汇最短路与单汇最短路">各算法的全汇最短路与单汇最短路</h3> <p>上述的三种算法给出的伪码和模板都是用于求解单源全汇最短路的，当然全汇都已经求解出来，对于给定的汇点也是得到了答案，但是了解各点的最短路究竟是在算法的那个步骤求解出来对于深入理解算法本身很有帮助，或者在某些情况下我们需要在得到给定汇点的最短路便及时退出。包括下文的BFS、A*求解最短路，这里一起讨论一下。</p> <table> <thead> <tr> <th style="text-align: right">具体算法</th> <th>何时得到解</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">Dijkstra系列算法</td> <td>对于所有节点，“被弹出时”得到解，即被确定为当前未确定的结点中距离源点最近时</td> </tr> <tr> <td style="text-align: right">Bellman-Ford、SPFA算法</td> <td>对于所有节点，“算法结束时”得到解</td> </tr> <tr> <td style="text-align: right">BFS求解最短路问题</td> <td>对于所有结点，“被插入时”得到解，即被松弛成功、被探索到时</td> </tr> <tr> <td style="text-align: right">A*算法</td> <td>对于且仅对于给定汇点，“第k次弹出时”得到“第k短路”的解</td> </tr> </tbody> </table> <h3 id="bfs适用的最短路问题">BFS适用的最短路问题</h3> <p>BFS是可以求解无权最短路和01权值最短路问题的。因为BFS是满足“最小性”的搜索，故可以求解。下面详细讨论。</p> <h4 id="bfs如何求解特定的最短路问题">BFS如何求解特定的最短路问题</h4> <p>首先BFS搜索的“最小性”是如何被满足的？BFS所维护的数据结构是队列，如果用\(x\)表示搜索过程中第\(x\)步探索到的结点，那么直观的，任意时刻队列都满足如下形式： \(\{ \underbrace{x, x, x,\cdots}_{cnt(x)\geqslant 0}, \underbrace{\cdots,x + 1, x + 1, x + 1}_{cnt(x + 1)\geqslant 0} \}\) 可以称这种性质为“两段性”，前一段小于后一段，也即任意时刻队列是满足单调性的，故对于无权最短路当第一次搜索到汇点时，一定经历了最短的步数。</p> <p>那么对于01权值最短路，我们只要想办法保证维护数据结构的单调性，就依旧可解。方法是使用双端队列代替普通队列，当探索权值为0的边时，将节点插入队首就可保证其两段性，进一步保证了单调性和正确性。</p> <p>继续思考下去的话，如果是多权值还想要保证数据结构的单调性，就需要堆了，此时BFS就弱化为Dijkstra算法了。</p> <table> <thead> <tr> <th style="text-align: right"> </th> <th style="text-align: center">普通BFS</th> <th style="text-align: center">双端队列维护的BFS</th> <th style="text-align: center">Dijkstra</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">边权</td> <td style="text-align: center">1</td> <td style="text-align: center">0、1</td> <td style="text-align: center">非负</td> </tr> <tr> <td style="text-align: right">最短路何时确定</td> <td style="text-align: center">被探索到时</td> <td style="text-align: center">被用于探索时</td> <td style="text-align: center">被用于探索时</td> </tr> <tr> <td style="text-align: right">数据结构</td> <td style="text-align: center">普通队列</td> <td style="text-align: center">双端队列</td> <td style="text-align: center">小根堆</td> </tr> <tr> <td style="text-align: right">各节点插入的次数</td> <td style="text-align: center">不大于1</td> <td style="text-align: center">不大于2</td> <td style="text-align: center">小于总结点数</td> </tr> </tbody> </table> <h4 id="bfs适用的最短路模型">BFS适用的最短路模型</h4> <h5 id="最小步数模型">最小步数模型</h5> <p>此种模型较为简单，其特点是图的结构是给定的、不会变化的，一般为棋盘或迷宫之类，求解图上两点的最小步数，各节点能选择的分支很少，其构成的图一定是一张稀疏图。</p> <h5 id="最少转换模型">最少转换模型</h5> <p>此种模型一定是单源单汇问题，也一定构成了一张稠密图。一般给定源点和汇点的结点状态和转换规则，求解最少转换的次数。比较经典的比如8数码问题、15数码问题。一般BFS是求解此类问题的基础，但是需要优化。由于每个节点可拓展的分支数一般很多，在搜索过程中访问的结点程指数形式增长，需要优化。</p> <h6 id="使用双向bfs算法优化">使用双向BFS算法优化</h6> <p>不难想象，使用BFS搜索，假设汇点在第\(k\)层，每个节点有\(x\)个分支，则需要搜索\(x^k\)这样一个级别的节点数。而使用双向BFS算法，从源点和汇点同时向中间状态搜索，则将在第\(\lfloor \frac k2\rfloor\)层相遇，搜索的节点数量级为\(2\times x^{\frac k2}\)。</p> <blockquote> <p>重要的技巧：源点和汇点各维护一个队列，每次应选取队列中元素较少的那一方继续搜索，以保持两边搜索的结点数尽量接近，达到优化的目的。</p> </blockquote> <h6 id="使用a算法优化">使用A*算法优化</h6> <p>A*算法可以完美求解\(k\)短路问题(下文说到)，我们令\(k = 1\)则可以用于优化最短路问题。但使用A*算法优化最短路问题并非仅仅是令\(k = 1\)。A*算法求解这两个问题的实际应用不尽相同。</p> <table> <thead> <tr> <th style="text-align: right"> </th> <th style="text-align: center">k短路问题</th> <th style="text-align: center">优化单源单汇最短路问题</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">着重点</td> <td style="text-align: center">小根堆第k次弹出第k短路</td> <td style="text-align: center">估价函数优化搜索方案</td> </tr> <tr> <td style="text-align: right">拓展节点</td> <td style="text-align: center">拓展所有节点，因为只有重复拓展才会有k短路</td> <td style="text-align: center">若边权唯一，同BFS；若边权不唯一，同Dijkstra</td> </tr> <tr> <td style="text-align: right">维护路径</td> <td style="text-align: center">基于上面拓展节点的方式，不可以</td> <td style="text-align: center">基于上面拓展节点的方式，可以</td> </tr> <tr> <td style="text-align: right">何时得到解</td> <td style="text-align: center">汇点第k次被用于探索时</td> <td style="text-align: center">若边权唯一，同BFS；若边权不唯一，同Dijkstra</td> </tr> </tbody> </table> <p>A*算法的效率取决于估价函数\(g(e)\)（即预估节点\(e\)到汇点的距离）的准确性。一般可用于最少转换模型（使用该算法，转化操作可以带权）和求解第k短路。用于最少转化模型时如果存在网格结构，可以从曼哈顿距离<sup id="fnref:m_dist" role="doc-noteref"><a href="#fn:m_dist" class="footnote">2</a></sup>的方向思考一下估价函数。</p> <h3 id="单源最短路的各种拓展">单源最短路的各种拓展</h3> <h4 id="边数限制为k的最短路与bellman-ford算法">边数限制为k的最短路与Bellman-Ford算法</h4> <p>前文中说道Bellman-Ford算法在基础最短路问题中没有优势，但是其也有特殊性，即求解边数限制为\(k\)的最短路</p> <blockquote> <p>时间复杂度： \(O(n\cdot m)\)</p> <p>一句话核心思想：\(k\)次对所有边使用备份距离尝试松弛</p> </blockquote> \[\begin{aligned} data\ structure&amp;\\ &amp;数组dis：源点到各点的最短路径\\ &amp;数组bak：数组dis的备份\\ initialization&amp;\\ &amp;dis(e) = \begin{cases} INF,&amp;e \not = source\\ 0,&amp;e = source \end{cases}\\ core\ algorithm&amp;\\ &amp;loop\quad k\ times\\ &amp;\hphantom{loop\quad}copy\ dis\ to\ bak\\ &amp;\hphantom{loop\quad}dis(u) = min\{ dis(u), bak(e) + d(e, u) \} \end{aligned}\] <blockquote> <p>注意：由于在负权图中\(INF\)可以被负权边松弛成功，所以要提前判断\(bak(e)\)不是\(INF\)。</p> </blockquote> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">type</span> <span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">SP_Bellman_Ford</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
<span class="nl">public:</span>
	<span class="k">struct</span> <span class="nc">node</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">;</span>
		<span class="n">type</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ar</span><span class="p">[</span><span class="n">maxm</span><span class="p">];</span>
	<span class="n">type</span> <span class="n">INF</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="mi">1u</span><span class="p">;</span>
	<span class="n">type</span> <span class="n">dis</span><span class="p">[</span><span class="n">maxn</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">bak</span><span class="p">[</span><span class="n">maxn</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">explicit</span> <span class="n">SP_Bellman_Ford</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span> <span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">m</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{}</span>
	<span class="kt">void</span> <span class="n">solve</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">source</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fill</span><span class="p">(</span><span class="n">dis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dis</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>
		<span class="n">dis</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">copy</span><span class="p">(</span><span class="n">dis</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dis</span><span class="o">+</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">bak</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bak</span><span class="p">[</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">from</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INF</span><span class="p">)</span>
					<span class="n">dis</span><span class="p">[</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dis</span><span class="p">[</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">],</span> <span class="n">bak</span><span class="p">[</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">from</span><span class="p">]</span> <span class="o">+</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="多个可选源点最短路">多个可选源点最短路</h4> <blockquote> <p>思考方式</p> </blockquote> <p>通过增加一个虚拟源点，规定其到可选源点距离为\(0\)，到其他节点距离为\(INF\)，便转化为普通的单源最短路</p> <blockquote> <p>编码方法</p> </blockquote> <p>将本来作用于单个源点的初始化作用于所有可选源点即可</p> <h4 id="正权图上的次短路与dijkstra算法">正权图上的次短路与Dijkstra算法</h4> <p>将\(vis、dis\)维护两组即可，松弛的时候讨论当前的路小于最短路，或者大于最短路但小于次短路这两种情况，就能维护一个次短路了。</p> <p>理论上任何第\(k\)（确定值）短路都可以用此方法求解，但并不实用。</p> <h4 id="k短路与a算法">k短路与A*算法</h4> <p>A*算法上文讨论过，这里给出使用A*求解k短路问题的详细算法思想。</p> <blockquote> <p>A*算法保证正确性的前提：对于任意节点，估价函数不大于实际值。</p> <p>使用A*搜索时使用小根堆维护节点（对于节点\(e\)，维护信息为\(\{g(e) + dis(e), \{ dis(e), e \}\}\)，其中\(dis(e)\)不需要额外维护）。</p> </blockquote> \[\begin{aligned} DATA&amp;\\ &amp;估价函数ge: 各点到汇点的距离估价(不大于实际距离)\\ &amp;小根堆srp:\ &lt;g(e) + dis(e), &lt;dis(e), e&gt;&gt;\\ INIT&amp;\\ &amp;根据曼哈顿距离或反向最短路构造估价函数ge\\ &amp;push\ source\ to\ srp\\ CORE&amp;\\ &amp;cnt = 0\\ &amp;\!\begin{aligned} loop\quad&amp;until\ srp\ is\ empty\\ &amp;pop\ cur\ from\ srp\\ &amp;\!\begin{aligned} if\quad&amp;cur == sink\mbox{ &amp;&amp; }+\!\!+cnt == k\\ &amp;return\quad dis(cur) \end{aligned}\\ &amp;\forall u\in\{ cur's\ successors \}\\ &amp;\quad\quad push\ \{ g(u) + dis(cur) + d(cur, u), \{ dis(cur) + d(cur, u), u \} \}\ into\ srp \end{aligned} \end{aligned}\] <h4 id="维护路径最短路">维护路径最短路</h4> <p>有时候我们需要维护找到的最短路的路径。也很简单，只要记录每个节点是如何被搜索到的（比如由哪个节点拓展而来、有哪个方向搜索得到等等），只要根据记录可以从汇点反推得到路径就OK。</p> <blockquote> <p>Tips: 可以直接在反向图上执行算法，那么就无需反推了——反向图的逆向路径即正向图的正向路径。</p> </blockquote> <h5 id="最小字典序路径">最小字典序路径</h5> <p>既然要求解最小字典序的最短路径，就一定存在评判大小的标准，在执行算法时按照约定顺序拓展即可。</p> <h5 id="所有路径">所有路径</h5> <p>先使用最短路算法得到最短路径长度。然后使用dfs得到所有最短路，如果要求顺序，dfs的过程遵守约定顺序即可。</p> <h2 id="其他">其他</h2> <h3 id="spfa算法与判断负环">SPFA算法与判断负环</h3> <p>和最短路问题经常一同出现的对负权图的判断负环，Bellman-Ford算法和SPFA算法都可以求解，因为SPFA算法的时间复杂度优秀，故使用SPFA算法求解。</p> <blockquote> <p>如何求解？</p> </blockquote> <p>根据抽屉原理，对于一张有\(n\)个节点的图，若一条最短路上有\(n\)条边，即\(n + 1\)个节点，则至少有一个节点出现次数不小于2次，即出现了负环。</p> \[\begin{aligned} data\ structure&amp;\\ &amp;数组dis：源点到各点的最短路径(在判断负环时，此意义不重要)\\ &amp;数组cnt：源点到各点的最短路径边数\\ &amp;集合vis：满足状态「被松弛成功但尚未向后进行松弛操作」的结点的集合\\ &amp;队列que：&lt;e&gt;, e\in Vertex\\ initialization&amp;\\ &amp;\forall e\in Vertex,cnt(e) = 0\\ &amp;保证该图的所有联通子图至少有一个节点放入vis\\ &amp;放入vis的结点同样需要放入que\\ core\ algorithm&amp;\\ &amp;loop\quad untill\ que\ is\ empty\\ &amp;\hphantom{loop\quad}pop\ cur\ from\ que\\ &amp;\hphantom{loop\quad}delete\ cur\ from\ vis\\ &amp;\hphantom{loop\quad}if\quad relax(cur, u),u\in \{ u's\ successors \}\ is\ successful\\ &amp;\hphantom{loop\quad if\quad}cnt(u) = cnt(e) + 1\\ &amp;\hphantom{loop\quad if\quad}if\quad cnt(u)\ equals\ the\ size\ of\ Vertexs\\ &amp;\hphantom{loop\quad if\quad if\quad}存在负环\\ &amp;\hphantom{loop\quad if\quad}if\quad u\not\in vis\\ &amp;\hphantom{loop\quad if\quad if\quad}push\ u\ in\ vis\\ &amp;\hphantom{loop\quad if\quad if\quad}push\ u\ in\ que\\ &amp;若算法执行结束未发现负环则不存在 \end{aligned}\] <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">type</span> <span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">SP</span> <span class="p">{</span>
	<span class="k">const</span> <span class="n">type</span> <span class="n">INF</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span> <span class="n">type</span> <span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">1u</span><span class="p">;</span>
	<span class="n">type</span> <span class="n">dis</span><span class="p">[</span><span class="n">maxn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{};</span>
	<span class="kt">bool</span> <span class="n">vis</span><span class="p">[</span><span class="n">maxn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{};</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">[</span><span class="n">maxn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{};</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">queue</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">que</span><span class="p">;</span>
<span class="nl">public:</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="n">ptr</span><span class="p">;</span>
		<span class="n">type</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">ar</span><span class="p">[</span><span class="n">maxm</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{};</span>
	<span class="kt">int</span> <span class="n">head</span><span class="p">[</span><span class="n">maxn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="p">{};</span>
	<span class="k">explicit</span> <span class="n">SP</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{}</span>
	<span class="kt">bool</span> <span class="n">solve</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">fill</span><span class="p">(</span><span class="n">vis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vis</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">fill</span><span class="p">(</span><span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">fill</span><span class="p">(</span><span class="n">dis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dis</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">INF</span><span class="p">);</span>	<span class="c1">// 初始化为INF有利于防止溢出</span>
		<span class="n">queue</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span><span class="p">().</span><span class="n">swap</span><span class="p">(</span><span class="n">que</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">static</span> <span class="kt">int</span> <span class="n">cur</span><span class="p">;</span>
			<span class="n">cur</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">(),</span> <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">vis</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">head</span><span class="p">[</span><span class="n">cur</span><span class="p">];</span> <span class="n">i</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ptr</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dis</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">+</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">dis</span><span class="p">[</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">])</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">cnt</span><span class="p">[</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
					<span class="n">dis</span><span class="p">[</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">dis</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span> <span class="o">+</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">])</span> <span class="p">{</span>
						<span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">);</span>
						<span class="n">vis</span><span class="p">[</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:link_astar" role="doc-endnote"> <p>一种使用数组模拟链表的结构，本博客会在后面数据结构的专题文章中进行详细说明。 <a href="#fnref:link_astar" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:m_dist" role="doc-endnote"> <p>在欧几里得空间的固定直角坐标系上两点所形成的线段对轴产生的投影的距离总和. <a href="#fnref:m_dist" class="reversefootnote" role="doc-backlink">↩</a></p> </li> </ol> </div> </div> </div> </div> </div> </div> <footer> <div class="container"> <div class="row"> <div class="col-lg-8"> <p>Mooyyu Crab.'s Blog <i class="fa fa-heart text-danger" aria-hidden="true"></i>. Check out <a href="//github.com/mooyyu/mooyyu.github.io" target="_blank">Github Project <i class="fa fa-github-alt" aria-hidden="true"></i></a>.<br> The contents of this website are © 2021 under the terms of the <a href="//www.gnu.org/licenses/gpl-3.0.txt" target="_blank">GPLv3</a> License.</p> </div> <div class="col-lg-4"> <div class="pull-right"> <a href="#top" data-proofer-ignore> Back to top <i class="fa fa-level-up" aria-hidden="true"></i></a> </div> </div> </div> </div> </footer> <div style="width: 100%; overflow-x: hidden;"> <canvas class="fireworks" style="position:fixed;left:0;top:0;z-index:99999999;pointer-events:none;"></canvas> </div> <script>
  MathJax = {
    options: {
      enableMenu: false
    }
  };
</script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js"></script> <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-128176907-1', {
          'cookieDomain': 'mooyyu.github.io',
          'siteSpeedSampleRate': 80
      });

      ga('require', 'displayfeatures');
      ga('send', 'pageview');
    </script> </body> </html>
